import code
import contextlib
import io
import os
import pdb
import socket
import sys
from types import FrameType
from typing import Any, AnyStr, BinaryIO, Callable, Dict, Optional, Tuple, Union

class PdbStr(str):
    def __new__(cls, value: str, prompt: bool = False) -> PdbStr: ...
    is_prompt: bool = ...

class PdbIOWrapper(io.TextIOBase):
    def __init__(self, sock: socket.socket) -> None: ...
    def detach(self) -> BinaryIO: ...
    def read(self, size: Optional[int] = -1) -> AnyStr: ...
    def readline(self, size: Optional[int] = -1) -> AnyStr: ...
    def read_prompt(self) -> Tuple[AnyStr, bool]: ...
    def raise_eoferror(self) -> bool: ...
    def write(self, msg: str) -> int: ...
    def flush(self) -> None: ...

class PdbInteractiveConsole(code.InteractiveConsole):
    def __init__(
        self,
        pdb_io: PdbIOWrapper,
        locals: Optional[Dict[str, Any]] = None,
        filename: str = "<console>",
    ) -> None: ...
    def raw_input(self, prompt: str = "") -> str: ...
    def write(self, data: str) -> None: ...

class PdbServer(pdb.Pdb):
    def __init__(self, port: Union[int, str], *args: Any, **kwargs: Any) -> None: ...
    def set_trace(self, frame: Optional[FrameType] = ...) -> None: ...
    def do_interact(self, arg: Any) -> None: ...
    def close(self) -> None: ...

class PdbClient:
    server_pid: int = ...
    port: Union[int, str] = ...
    def __init__(self, pid: int, port: Union[int, str]) -> None: ...
    def connect(self) -> None: ...
    def raise_eoferror(self) -> Tuple[str, bool]: ...
    def send_cmd(self, cmd: str) -> None: ...
    send: Callable[[str], None] = ...
    def recv(self) -> Tuple[str, bool]: ...
    def send_and_recv(self, cmd: str) -> Tuple[str, bool]: ...
    def interactive_loop(self) -> None: ...
